# 数据库备份管理

数据库备份管理功能，支持自动备份、手动备份和一键下载（后端自动解密）。

## 功能特性

### 备份管理

- **自动备份**：每天凌晨 2 点自动执行
- **手动备份**：支持手动触发备份
- **备份列表**：查看所有备份记录
- **一键下载**：后端自动解密，直接下载 .sql.gz 文件
- **备份统计**：查看备份统计信息（总数、大小、类型分布）

## 快速开始

### 使用备份管理

1. 访问备份管理页面
2. 点击"手动备份"按钮触发备份
3. 在列表中查看备份记录
4. 点击"下载"按钮，后端自动解密并下载

## 文件格式说明

### 存储格式（.sql.gz.enc）

- **格式**：SQL → Gzip → AES-256-CBC
- **命名**：`backup-{type}-{timestamp}.sql.gz.enc`
- **存储**：阿里云 OSS / MinIO

### 下载格式（.sql.gz）

- **格式**：SQL → Gzip（后端已解密）
- **命名**：`backup-{type}-{timestamp}.sql.gz`
- **使用**：可直接导入数据库或解压查看

## 下载流程

```
用户点击下载
    ↓
前端调用 /backups/download 接口
    ↓
后端从 OSS 下载加密文件
    ↓
后端自动解密文件
    ↓
后端返回解密后的 .sql.gz 文件
    ↓
浏览器自动下载
```

## 技术实现

### 前端技术栈

- **React**：UI 框架
- **Ant Design**：组件库
- **ProTable**：高级表格组件
- **dayjs**：日期处理

### 后端解密

- **算法**：AES-256-CBC
- **密钥派生**：
  - Key: SHA-256(secret) - 32 字节
  - IV: MD5(secret) - 16 字节
- **流程**：下载 → 解密 → 返回

### 下载方案

采用后端解密方案：

1. 前端调用 `/backups/download` 接口
2. 后端从 OSS 下载加密文件
3. 后端自动解密文件
4. 后端返回解密后的 .sql.gz 文件
5. 浏览器自动下载

## 目录结构

```
src/pages/database-backup/
├── index.jsx                           # 主页面
├── components/
│   └── DatabaseBackupProTable.jsx      # 备份列表组件
├── README.md                           # 本文档
└── DOWNLOAD_GUIDE.md                   # 下载指南
```

## 使用场景

### 场景 1：定期备份

系统每天凌晨 2 点自动执行备份，无需人工干预。

### 场景 2：手动备份

在重要操作前（如数据迁移、系统升级），手动触发备份。

### 场景 3：数据恢复

1. 从备份列表下载文件（后端自动解密）
2. 解压 .sql.gz 文件
3. 导入数据库

### 场景 4：数据审计

1. 下载历史备份（后端自动解密）
2. 解压 .sql.gz 文件
3. 查看 SQL 文件内容
4. 进行数据审计

## 安全考虑

### 1. 加密存储

- 所有备份文件都经过 AES-256-CBC 加密
- 密钥存储在后端环境变量中
- 不同环境使用不同的密钥

### 2. 权限控制

- 只有超级管理员可以访问备份管理
- 所有操作都会记录日志
- 下载接口受权限保护

### 3. 后端解密

- 解密操作在后端完成
- 密钥不暴露给前端
- 保护数据安全

### 4. 传输安全

- 使用 HTTPS 传输
- 解密后的文件直接流式传输
- 不在服务器保存解密文件

## 文件恢复

### 1. 解压 SQL 文件

```bash
gunzip backup-manual-20251112-104643.sql.gz
```

解压后得到：`backup-manual-20251112-104643.sql`

### 2. 导入数据库

```bash
# 方法 1：使用 mysql 命令
mysql -h localhost -u root -p database_name < backup-manual-20251112-104643.sql

# 方法 2：使用 source 命令
mysql -h localhost -u root -p
mysql> use database_name;
mysql> source /path/to/backup-manual-20251112-104643.sql;
```

## 故障排查

### 问题 1：下载失败

**症状**：点击下载按钮后没有反应

**解决方法**：
1. 检查网络连接
2. 检查浏览器控制台错误信息
3. 确认有下载权限
4. 重试下载

### 问题 2：文件损坏

**症状**：下载的文件无法解压或导入数据库

**解决方法**：
1. 重新下载备份文件
2. 检查文件大小是否正确
3. 联系系统管理员

### 问题 3：解密失败

**症状**：后端返回解密失败错误

**解决方法**：
1. 检查后端日志
2. 确认加密密钥配置正确
3. 确认文件未损坏
4. 联系系统管理员

## 性能优化

### 1. 大文件处理

- 后端使用流式处理
- 避免一次性加载到内存
- 支持大文件下载（>100MB）

### 2. 下载速度

- 使用 HTTP 流式传输
- 支持断点续传（浏览器自动处理）
- 优化网络传输

### 3. 用户体验

- 显示下载状态
- 提供清晰的错误提示
- 支持并发下载

## 与浏览器端解密的对比

| 特性 | 后端解密（当前方案） | 浏览器端解密 |
|------|---------------------|-------------|
| 安全性 | ✅ 密钥不暴露 | ⚠️ 需要输入密钥 |
| 性能 | ✅ 服务器处理 | ⚠️ 浏览器性能限制 |
| 大文件 | ✅ 支持任意大小 | ❌ 受浏览器内存限制 |
| 用户体验 | ✅ 一键下载 | ⚠️ 需要多步操作 |
| 实现复杂度 | ✅ 简单 | ⚠️ 需要额外依赖 |

## 技术说明

### 下载实现

使用 **fetch + Blob** 方案：

```javascript
// 1. 发送请求（携带认证头）
const response = await fetch(`/api/backups/download?fileKey=${fileKey}`, {
    headers: { Authorization: accessToken }
});

// 2. 检查响应状态
if (!response.ok) {
    const errorData = await response.json();
    throw new Error(errorData.msg);
}

// 3. 获取文件并下载
const blob = await response.blob();
const url = window.URL.createObjectURL(blob);
const link = document.createElement('a');
link.href = url;
link.download = fileName;
link.click();
```

**优势**：
- ✅ 可以携带认证头
- ✅ 可以获取响应状态
- ✅ 可以处理错误
- ✅ 可以自定义文件名

## 相关文档

- [开发规范](../../docs/DEVELOP_GUIDELINES.md) - 前端开发规范
